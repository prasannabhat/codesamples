<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0067)http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!-- RD version: 0.9.4  -->
  
  <title>Class: Net::HTTPSession (Ruby 1.9.3) </title>
  <!-- raw_prefix  = '..'   -->
  <link rel="stylesheet" href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/css/obf.css">

  <script src="./Class  Net  HTTPSession (Ruby 1.9.3)_files/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="./Class  Net  HTTPSession (Ruby 1.9.3)_files/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="./Class  Net  HTTPSession (Ruby 1.9.3)_files/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="./Class  Net  HTTPSession (Ruby 1.9.3)_files/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="./Class  Net  HTTPSession (Ruby 1.9.3)_files/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 
<script type="text/javascript" async="" src="./Class  Net  HTTPSession (Ruby 1.9.3)_files/embed.js"></script><script src="./Class  Net  HTTPSession (Ruby 1.9.3)_files/thread.js" async="" charset="UTF-8"></script><link rel="stylesheet" type="text/css" href="./Class  Net  HTTPSession (Ruby 1.9.3)_files/defaults.css"><script src="./Class  Net  HTTPSession (Ruby 1.9.3)_files/disqus.js" async="" charset="UTF-8"></script></head>

<body id="top" class="class">
<div id="actionbar">
<div class="wrapper">
<ul class="grids g0">
  <li class="grid-2"><a href="http://ruby-doc.org/" target="_top">Home</a></li>
  <li class="grid-2"><a href="http://ruby-doc.org/core" target="_top">Core</a></li>
  <li class="grid-2"><a href="http://ruby-doc.org/stdlib" target="_top">Std-lib</a></li>
  <li class="grid-2"><a href="http://ruby-doc.org/downloads" target="_top">Downloads</a></li>
  <li class="grid-7 right" id="rd-action-search"><form id="searchbox_011815814100681837392:wnccv6st5qk" action="http://ruby-doc.org/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk"><input name="q" type="text" size="20">&nbsp;&nbsp;<input type="submit" name="sa" value="Search"><input type="hidden" name="cof" value="FORID:9"></form>
</li>
</ul>
</div>
</div> <!-- end action bar -->
          <div class="wrapper">
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/index.html">Home</a>
          <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/index.html#classes">Classes</a>
          <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/net/http_rb.html?TB_iframe=true&height=550&width=785" class="thickbox" title="net/http.rb">net/http.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link">Protocol</p>
        
      </div>
      

      

      
      <!-- Namespace Contents -->
      <div id="namespace-list-section" class="section">
        <h3 class="section-header">Namespace</h3>
        <ul class="link-list">
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Copy.html">Net::HTTP::Copy</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Delete.html">Net::HTTP::Delete</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Get.html">Net::HTTP::Get</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Head.html">Net::HTTP::Head</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Lock.html">Net::HTTP::Lock</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Mkcol.html">Net::HTTP::Mkcol</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Move.html">Net::HTTP::Move</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Options.html">Net::HTTP::Options</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Patch.html">Net::HTTP::Patch</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Post.html">Net::HTTP::Post</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Propfind.html">Net::HTTP::Propfind</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Proppatch.html">Net::HTTP::Proppatch</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Put.html">Net::HTTP::Put</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Trace.html">Net::HTTP::Trace</a></li>
          
          <li><span class="type">CLASS</span> <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Unlock.html">Net::HTTP::Unlock</a></li>
          
        </ul>
      </div>
      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-Proxy">::Proxy</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-default_port">::default_port</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-get">::get</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-get_print">::get_print</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-get_response">::get_response</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-http_default_port">::http_default_port</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-https_default_port">::https_default_port</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-is_version_1_2-3F">::is_version_1_2?</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-new">::new</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-new">::new</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-newobj">::newobj</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-post_form">::post_form</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-proxy_class-3F">::proxy_class?</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-start">::start</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-version_1_2">::version_1_2</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-version_1_2-3F">::version_1_2?</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-active-3F">#active?</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-continue_timeout-3D">#continue_timeout=</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-copy">#copy</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-delete">#delete</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-finish">#finish</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-get">#get</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-get2">#get2</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-head">#head</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-head2">#head2</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-inspect">#inspect</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-lock">#lock</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-mkcol">#mkcol</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-move">#move</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-options">#options</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-patch">#patch</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-peer_cert">#peer_cert</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-post">#post</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-post2">#post2</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-propfind">#propfind</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proppatch">#proppatch</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy-3F">#proxy?</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy_address">#proxy_address</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy_pass">#proxy_pass</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy_port">#proxy_port</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy_user">#proxy_user</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxyaddr">#proxyaddr</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxyport">#proxyport</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-read_timeout-3D">#read_timeout=</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-request">#request</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-request_get">#request_get</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-request_head">#request_head</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-request_post">#request_post</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-send_request">#send_request</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-set_debug_output">#set_debug_output</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-start">#start</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-started-3F">#started?</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-trace">#trace</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-unlock">#unlock</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-use_ssl-3D">#use_ssl=</a></li>
          
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-use_ssl-3F">#use_ssl?</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./Class  Net  HTTPSession (Ruby 1.9.3)_files/find.png" height="16" width="16" alt="[+]" title="show/hide quicksearch"></span></h3>
        <form action="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value="" class="quicksearch-field">
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net.html">Net</a></li>
        
          <li><a href="./Class  Net  HTTPSession (Ruby 1.9.3)_files/Class  Net  HTTPSession (Ruby 1.9.3).htm">Net::HTTP</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Copy.html">Net::HTTP::Copy</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Delete.html">Net::HTTP::Delete</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Get.html">Net::HTTP::Get</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Head.html">Net::HTTP::Head</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Lock.html">Net::HTTP::Lock</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Mkcol.html">Net::HTTP::Mkcol</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Move.html">Net::HTTP::Move</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Options.html">Net::HTTP::Options</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Patch.html">Net::HTTP::Patch</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Post.html">Net::HTTP::Post</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Propfind.html">Net::HTTP::Propfind</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Proppatch.html">Net::HTTP::Proppatch</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Put.html">Net::HTTP::Put</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Trace.html">Net::HTTP::Trace</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Unlock.html">Net::HTTP::Unlock</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPAccepted.html">Net::HTTPAccepted</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPBadGateway.html">Net::HTTPBadGateway</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPBadRequest.html">Net::HTTPBadRequest</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPBadResponse.html">Net::HTTPBadResponse</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPClientError.html">Net::HTTPClientError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPConflict.html">Net::HTTPConflict</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPContinue.html">Net::HTTPContinue</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPCreated.html">Net::HTTPCreated</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPError.html">Net::HTTPError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPError.html">Net::HTTPError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPError.html">Net::HTTPError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPError.html">Net::HTTPError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPExceptions.html">Net::HTTPExceptions</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPExpectationFailed.html">Net::HTTPExpectationFailed</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPFatalError.html">Net::HTTPFatalError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPForbidden.html">Net::HTTPForbidden</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPFound.html">Net::HTTPFound</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPFound.html">Net::HTTPFound</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPGatewayTimeOut.html">Net::HTTPGatewayTimeOut</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPGenericRequest.html">Net::HTTPGenericRequest</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPGone.html">Net::HTTPGone</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPHeader.html">Net::HTTPHeader</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPHeaderSyntaxError.html">Net::HTTPHeaderSyntaxError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPInformation.html">Net::HTTPInformation</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPInternalServerError.html">Net::HTTPInternalServerError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPLengthRequired.html">Net::HTTPLengthRequired</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPMethodNotAllowed.html">Net::HTTPMethodNotAllowed</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPMovedPermanently.html">Net::HTTPMovedPermanently</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPMultipleChoice.html">Net::HTTPMultipleChoice</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPNoContent.html">Net::HTTPNoContent</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPNonAuthoritativeInformation.html">Net::HTTPNonAuthoritativeInformation</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPNotAcceptable.html">Net::HTTPNotAcceptable</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPNotFound.html">Net::HTTPNotFound</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPNotImplemented.html">Net::HTTPNotImplemented</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPNotModified.html">Net::HTTPNotModified</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPOK.html">Net::HTTPOK</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPPartialContent.html">Net::HTTPPartialContent</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPPaymentRequired.html">Net::HTTPPaymentRequired</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPPreconditionFailed.html">Net::HTTPPreconditionFailed</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPProxyAuthenticationRequired.html">Net::HTTPProxyAuthenticationRequired</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRedirection.html">Net::HTTPRedirection</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRequest.html">Net::HTTPRequest</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRequestEntityTooLarge.html">Net::HTTPRequestEntityTooLarge</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRequestTimeOut.html">Net::HTTPRequestTimeOut</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRequestURITooLong.html">Net::HTTPRequestURITooLong</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRequestURITooLong.html">Net::HTTPRequestURITooLong</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRequestedRangeNotSatisfiable.html">Net::HTTPRequestedRangeNotSatisfiable</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResetContent.html">Net::HTTPResetContent</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRetriableError.html">Net::HTTPRetriableError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRetriableError.html">Net::HTTPRetriableError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPSeeOther.html">Net::HTTPSeeOther</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPServerError.html">Net::HTTPServerError</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPServerException.html">Net::HTTPServerException</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPServiceUnavailable.html">Net::HTTPServiceUnavailable</a></li>
        
          <li><a href="./Class  Net  HTTPSession (Ruby 1.9.3)_files/Class  Net  HTTPSession (Ruby 1.9.3).htm">Net::HTTPSession</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPSuccess.html">Net::HTTPSuccess</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPSwitchProtocol.html">Net::HTTPSwitchProtocol</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPTemporaryRedirect.html">Net::HTTPTemporaryRedirect</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPUnauthorized.html">Net::HTTPUnauthorized</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPUnknownResponse.html">Net::HTTPUnknownResponse</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPUnsupportedMediaType.html">Net::HTTPUnsupportedMediaType</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPUseProxy.html">Net::HTTPUseProxy</a></li>
        
          <li><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPVersionNotSupported.html">Net::HTTPVersionNotSupported</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">Net::HTTPSession</h1>

    <div id="description" class="description">
      
<h2>An HTTP client API for Ruby.</h2>

<p>Net::HTTP provides a rich library which can be used to build HTTP
user-agents.  For more details about HTTP see [RFC2616](<a href="http://www.ietf.org/rfc/rfc2616.txt">www.ietf.org/rfc/rfc2616.txt</a>)</p>

<p>Net::HTTP is designed to work closely with URI.  URI::HTTP#host,
URI::HTTP#port and URI::HTTP#request_uri are designed to work with
Net::HTTP.</p>

<p>If you are only performing a few GET requests you should try OpenURI.</p>

<h2>Simple Examples</h2>

<p>All examples assume you have loaded Net::HTTP with:</p>

<pre>require 'net/http'</pre>

<p>This will also require ‘uri’ so you don’t need to require it separately.</p>

<p>The Net::HTTP methods in the following section do not persist connections. 
They are not recommended if you are performing many HTTP requests.</p>

<h3>GET</h3>

<pre>Net::HTTP.get('example.com', '/index.html') # =&gt; String</pre>

<h3>GET by URI</h3>

<pre>uri = URI('http://example.com/index.html?count=10')
Net::HTTP.get(uri) # =&gt; String</pre>

<h3>GET with Dynamic Parameters</h3>

<pre>uri = URI('http://example.com/index.html')
params = { :limit =&gt; 10, :page =&gt; 3 }
uri.query = URI.encode_www_form(params)

res = Net::HTTP.get_response(uri)
puts res.body if res.is_a?(Net::HTTPSuccess)</pre>

<h3>POST</h3>

<pre>uri = URI('http://www.example.com/search.cgi')
res = Net::HTTP.post_form(uri, 'q' =&gt; 'ruby', 'max' =&gt; '50')
puts res.body</pre>

<h3>POST with Multiple Values</h3>

<pre>uri = URI('http://www.example.com/search.cgi')
res = Net::HTTP.post_form(uri, 'q' =&gt; ['ruby', 'perl'], 'max' =&gt; '50')
puts res.body</pre>

<h2>How to use Net::HTTP</h2>

<p>The following example code can be used as the basis of a HTTP user-agent
which can perform a variety of request types using persistent connections.</p>

<pre>uri = URI('http://example.com/some_path?query=string')

Net::HTTP.start(uri.host, uri.port) do |http|
  request = Net::HTTP::Get.new uri.request_uri

  response = http.request request # Net::HTTPResponse object
end</pre>

<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-start">Net::HTTP::start</a> immediately creates
a connection to an HTTP server which is kept open for the duration of the
block.  The connection will remain open for multiple requests in the block
if the server indicates it supports persistent connections.</p>

<p>The request types Net::HTTP supports are listed below in the section “HTTP
Request Classes”.</p>

<p>If you wish to re-use a connection across multiple HTTP requests without
automatically closing it you can use <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-new">::new</a> instead of <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-start">::start</a>.  <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-request">request</a> will automatically open a
connection to the server if one is not currently open.  You can manually
close the connection with <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-finish">finish</a>.</p>

<h3>Response Data</h3>

<pre>uri = URI('http://example.com/index.html')
res = Net::HTTP.get_response(uri)

# Headers
res['Set-Cookie']            # =&gt; String
res.get_fields('set-cookie') # =&gt; Array
res.to_hash['set-cookie']    # =&gt; Array
puts "Headers: #{res.to_hash.inspect}"

# Status
puts res.code       # =&gt; '200'
puts res.message    # =&gt; 'OK'
puts res.class.name # =&gt; 'HTTPOK'

# Body
puts res.body if res.response_body_permitted?</pre>

<h3>Following Redirection</h3>

<p>Each <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a> object belongs to a
class for its response code.</p>

<p>For example, all 2XX responses are instances of a Net::HTTPSuccess
subclass, a 3XX response is an instance of a Net::HTTPRedirection subclass
and a 200 response is an instance of the Net::HTTPOK class.  For details of
response classes, see the section “HTTP Response Classes” below.</p>

<p>Using a case statement you can handle various types of responses properly:</p>

<pre>def fetch(uri_str, limit = 10)
  # You should choose a better exception.
  raise ArgumentError, 'too many HTTP redirects' if limit == 0

  response = Net::HTTP.get_response(URI(uri_str))

  case response
  when Net::HTTPSuccess then
    response
  when Net::HTTPRedirection then
    location = response['location']
    warn "redirected to #{location}"
    fetch(location, limit - 1)
  else
    response.value
  end
end

print fetch('http://www.ruby-lang.org')</pre>

<h3>POST</h3>

<p>A POST can be made using the <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Post.html">Net::HTTP::Post</a>
request class.  This example creates a urlencoded POST body:</p>

<pre>uri = URI('http://www.example.com/todo.cgi')
req = Net::HTTP::Post.new(uri.path)
req.set_form_data('from' =&gt; '2005-01-01', 'to' =&gt; '2005-03-31')

res = Net::HTTP.start(uri.hostname, uri.port) do |http|
  http.request(req)
end

case res
when Net::HTTPSuccess, Net::HTTPRedirection
  # OK
else
  res.value
end</pre>

<p>At this time Net::HTTP does not support multipart/form-data.  To send
multipart/form-data use <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPGenericRequest.html#method-i-body-3D">Net::HTTPRequest#body=</a>
and Net::HTTPRequest#content_type=:</p>

<pre>req = Net::HTTP::Post.new(uri.path)
req.body = multipart_data
req.content_type = 'multipart/form-data'</pre>

<p>Other requests that can contain a body such as PUT can be created in the
same way using the corresponding request class (<a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Put.html">Net::HTTP::Put</a>).</p>

<h3>Setting Headers</h3>

<p>The following example performs a conditional GET using the
If-Modified-Since header.  If the files has not been modified since the
time in the header a Not Modified response will be returned.  See RFC 2616
section 9.3 for further details.</p>

<pre>uri = URI('http://example.com/cached_response')
file = File.stat 'cached_response'

req = Net::HTTP::Get.new(uri.request_uri)
req['If-Modified-Since'] = file.mtime.rfc2822

res = Net::HTTP.start(uri.hostname, uri.port) {|http|
  http.request(req)
}

open 'cached_response', 'w' do |io|
  io.write res.body
end if res.is_a?(Net::HTTPSuccess)</pre>

<h3>Basic Authentication</h3>

<p>Basic authentication is performed according to [RFC2617](<a href="http://www.ietf.org/rfc/rfc2617.txt">www.ietf.org/rfc/rfc2617.txt</a>)</p>

<pre>uri = URI('http://example.com/index.html?key=value')

req = Net::HTTP::Get.new(uri.request_uri)
req.basic_auth 'user', 'pass'

res = Net::HTTP.start(uri.hostname, uri.port) {|http|
  http.request(req)
}
puts res.body</pre>

<h3>Streaming Response Bodies</h3>

<p>By default Net::HTTP reads an entire response into memory.  If you are
handling large files or wish to implement a progress bar you can instead
stream the body directly to an IO.</p>

<pre>uri = URI('http://example.com/large_file')

Net::HTTP.start(uri.host, uri.port) do |http|
  request = Net::HTTP::Get.new uri.request_uri

  http.request request do |response|
    open 'large_file', 'w' do |io|
      response.read_body do |chunk|
        io.write chunk
      end
    end
  end
end</pre>

<h3>HTTPS</h3>

<p>HTTPS is enabled for an HTTP connection by <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-use_ssl-3D">Net::HTTP#use_ssl=</a>.</p>

<pre>uri = URI('https://secure.example.com/some_path?query=string')

Net::HTTP.start(uri.host, uri.port,
  :use_ssl =&gt; uri.scheme == 'https').start do |http|
  request = Net::HTTP::Get.new uri.request_uri

  response = http.request request # Net::HTTPResponse object
end</pre>

<p>In previous versions of ruby you would need to require ‘net/https’ to use
HTTPS.  This is no longer true.</p>

<h3>Proxies</h3>

<p>Net::HTTP::Proxy has the same methods as Net::HTTP but its instances always
connect via the proxy instead of directly to the given host.</p>

<pre>proxy_addr = 'your.proxy.host'
proxy_port = 8080

Net::HTTP::Proxy(proxy_addr, proxy_port).start('www.example.com') {|http|
  # always connect to your.proxy.addr:8080
}</pre>

<p>Net::HTTP::Proxy returns a Net::HTTP instance when proxy_addr is nil so
there is no need for conditional code.</p>

<p>See Net::HTTP::Proxy for further details and examples such as proxies that
require a username and password.</p>

<h2>HTTP Request Classes</h2>

<p>Here is the HTTP request class hierarchy.</p>
<ul><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRequest.html">Net::HTTPRequest</a></p>
<ul><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Get.html">Net::HTTP::Get</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Head.html">Net::HTTP::Head</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Post.html">Net::HTTP::Post</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Put.html">Net::HTTP::Put</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Proppatch.html">Net::HTTP::Proppatch</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Lock.html">Net::HTTP::Lock</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Unlock.html">Net::HTTP::Unlock</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Options.html">Net::HTTP::Options</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Propfind.html">Net::HTTP::Propfind</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Delete.html">Net::HTTP::Delete</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Move.html">Net::HTTP::Move</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Copy.html">Net::HTTP::Copy</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Mkcol.html">Net::HTTP::Mkcol</a></p>
</li><li>
<p><a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Trace.html">Net::HTTP::Trace</a></p>
</li></ul>
</li></ul>

<h2>HTTP Response Classes</h2>

<p>Here is HTTP response class hierarchy.  All classes are defined in <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net.html">Net</a> module and are subclasses of <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a>.</p>
<table class="rdoc-list"><tbody><tr><td class="rdoc-term"><p>HTTPUnknownResponse</p></td>
<td>
<p>For unhandled HTTP extensions</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPInformation</p></td>
<td>
<p>1xx</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPContinue</p></td>
<td>
<p>100</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPSwitchProtocol</p></td>
<td>
<p>101</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPSuccess</p></td>
<td>
<p>2xx</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPOK</p></td>
<td>
<p>200</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPCreated</p></td>
<td>
<p>201</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPAccepted</p></td>
<td>
<p>202</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPNonAuthoritativeInformation</p></td>
<td>
<p>203</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPNoContent</p></td>
<td>
<p>204</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPResetContent</p></td>
<td>
<p>205</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPPartialContent</p></td>
<td>
<p>206</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPRedirection</p></td>
<td>
<p>3xx</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPMultipleChoice</p></td>
<td>
<p>300</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPMovedPermanently</p></td>
<td>
<p>301</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPFound</p></td>
<td>
<p>302</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPSeeOther</p></td>
<td>
<p>303</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPNotModified</p></td>
<td>
<p>304</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPUseProxy</p></td>
<td>
<p>305</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPTemporaryRedirect</p></td>
<td>
<p>307</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPClientError</p></td>
<td>
<p>4xx</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPBadRequest</p></td>
<td>
<p>400</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPUnauthorized</p></td>
<td>
<p>401</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPPaymentRequired</p></td>
<td>
<p>402</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPForbidden</p></td>
<td>
<p>403</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPNotFound</p></td>
<td>
<p>404</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPMethodNotAllowed</p></td>
<td>
<p>405</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPNotAcceptable</p></td>
<td>
<p>406</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPProxyAuthenticationRequired</p></td>
<td>
<p>407</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPRequestTimeOut</p></td>
<td>
<p>408</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPConflict</p></td>
<td>
<p>409</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPGone</p></td>
<td>
<p>410</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPLengthRequired</p></td>
<td>
<p>411</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPPreconditionFailed</p></td>
<td>
<p>412</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPRequestEntityTooLarge</p></td>
<td>
<p>413</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPRequestURITooLong</p></td>
<td>
<p>414</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPUnsupportedMediaType</p></td>
<td>
<p>415</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPRequestedRangeNotSatisfiable</p></td>
<td>
<p>416</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPExpectationFailed</p></td>
<td>
<p>417</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPServerError</p></td>
<td>
<p>5xx</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPInternalServerError</p></td>
<td>
<p>500</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPNotImplemented</p></td>
<td>
<p>501</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPBadGateway</p></td>
<td>
<p>502</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPServiceUnavailable</p></td>
<td>
<p>503</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPGatewayTimeOut</p></td>
<td>
<p>504</p>
</td></tr><tr><td class="rdoc-term"><p>HTTPVersionNotSupported</p></td>
<td>
<p>505</p>
</td></tr></tbody></table>

<p>There is also the Net::HTTPBadResponse exception which is raised when there
is a protocol error.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="SSL_ATTRIBUTES">SSL_ATTRIBUTES</a></dt>
          
          <dd class="description"></dd>
          
        
        </dl>
      </div>
      

      
      <!-- Attributes -->
      <div id="attribute-method-details" class="method-section section">
        <h3 class="section-header">Attributes</h3>

        
        <div id="proxy_address-attribute-method" class="method-detail">
          <a name="proxy_address"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">proxy_address</span><span class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>Address of proxy host. If Net::HTTP does not use a proxy, nil.</p>
          
          </div>
        </div>
        
        <div id="proxy_pass-attribute-method" class="method-detail">
          <a name="proxy_pass"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">proxy_pass</span><span class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>User password for accessing proxy. If Net::HTTP does not use a proxy, nil.</p>
          
          </div>
        </div>
        
        <div id="proxy_port-attribute-method" class="method-detail">
          <a name="proxy_port"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">proxy_port</span><span class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>Port number of proxy host. If Net::HTTP does not use a proxy, nil.</p>
          
          </div>
        </div>
        
        <div id="proxy_user-attribute-method" class="method-detail">
          <a name="proxy_user"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">proxy_user</span><span class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>User name for accessing proxy. If Net::HTTP does not use a proxy, nil.</p>
          
          </div>
        </div>
        
        <div id="address-attribute-method" class="method-detail">
          <a name="address"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">address</span><span class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>The DNS host name or IP address to connect to.</p>
          
          </div>
        </div>
        
        <div id="ca_file-attribute-method" class="method-detail">
          <a name="ca_file"></a>
          
          <a name="ca_file="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">ca_file</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets path of a CA certification file in PEM format.</p>

<p>The file can contain several CA certificates.</p>
          
          </div>
        </div>
        
        <div id="ca_path-attribute-method" class="method-detail">
          <a name="ca_path"></a>
          
          <a name="ca_path="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">ca_path</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets path of a CA certification directory containing certifications in PEM
format.</p>
          
          </div>
        </div>
        
        <div id="cert-attribute-method" class="method-detail">
          <a name="cert"></a>
          
          <a name="cert="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">cert</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets an OpenSSL::X509::Certificate object as client certificate. (This
method is appeared in Michal Rokos’s OpenSSL extension).</p>
          
          </div>
        </div>
        
        <div id="cert_store-attribute-method" class="method-detail">
          <a name="cert_store"></a>
          
          <a name="cert_store="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">cert_store</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets the X509::Store to verify peer certificate.</p>
          
          </div>
        </div>
        
        <div id="ciphers-attribute-method" class="method-detail">
          <a name="ciphers"></a>
          
          <a name="ciphers="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">ciphers</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets the available ciphers.  See OpenSSL::SSL::SSLContext#ciphers=</p>
          
          </div>
        </div>
        
        <div id="close_on_empty_response-attribute-method" class="method-detail">
          <a name="close_on_empty_response"></a>
          
          <a name="close_on_empty_response="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">close_on_empty_response</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          
          
          </div>
        </div>
        
        <div id="continue_timeout-attribute-method" class="method-detail">
          <a name="continue_timeout"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">continue_timeout</span><span class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>Seconds to wait for 100 Continue response.  If the HTTP object does not
receive a response in this many seconds it sends the request body.</p>
          
          </div>
        </div>
        
        <div id="key-attribute-method" class="method-detail">
          <a name="key"></a>
          
          <a name="key="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">key</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets an OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object. (This method is
appeared in Michal Rokos’s OpenSSL extension.)</p>
          
          </div>
        </div>
        
        <div id="open_timeout-attribute-method" class="method-detail">
          <a name="open_timeout"></a>
          
          <a name="open_timeout="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">open_timeout</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Number of seconds to wait for the connection to open. Any number may be
used, including Floats for fractional seconds. If the HTTP object cannot
open a connection in this many seconds, it raises a TimeoutError exception.</p>
          
          </div>
        </div>
        
        <div id="port-attribute-method" class="method-detail">
          <a name="port"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">port</span><span class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>The port number to connect to.</p>
          
          </div>
        </div>
        
        <div id="read_timeout-attribute-method" class="method-detail">
          <a name="read_timeout"></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">read_timeout</span><span class="attribute-access-type">[R]</span>
          </div>

          <div class="method-description">
          
          <p>Number of seconds to wait for one block to be read (via one read(2) call).
Any number may be used, including Floats for fractional seconds. If the
HTTP object cannot read data in this many seconds, it raises a TimeoutError
exception.</p>
          
          </div>
        </div>
        
        <div id="ssl_timeout-attribute-method" class="method-detail">
          <a name="ssl_timeout"></a>
          
          <a name="ssl_timeout="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">ssl_timeout</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets the SSL timeout seconds.</p>
          
          </div>
        </div>
        
        <div id="ssl_version-attribute-method" class="method-detail">
          <a name="ssl_version"></a>
          
          <a name="ssl_version="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">ssl_version</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets the SSL version.  See OpenSSL::SSL::SSLContext#ssl_version=</p>
          
          </div>
        </div>
        
        <div id="verify_callback-attribute-method" class="method-detail">
          <a name="verify_callback"></a>
          
          <a name="verify_callback="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">verify_callback</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets the verify callback for the server certification verification.</p>
          
          </div>
        </div>
        
        <div id="verify_depth-attribute-method" class="method-detail">
          <a name="verify_depth"></a>
          
          <a name="verify_depth="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">verify_depth</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets the maximum depth for the certificate chain verification.</p>
          
          </div>
        </div>
        
        <div id="verify_mode-attribute-method" class="method-detail">
          <a name="verify_mode"></a>
          
          <a name="verify_mode="></a>
          
          <div class="method-heading attribute-method-heading">
            <span class="method-name">verify_mode</span><span class="attribute-access-type">[RW]</span>
          </div>

          <div class="method-description">
          
          <p>Sets the flags for server the certification verification at beginning of
SSL/TLS session.</p>

<p>OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER are acceptable.</p>
          
          </div>
        </div>
        
      </div><!-- attribute-method-details -->
      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="Proxy-method" class="method-detail ">
          <a name="method-c-Proxy"></a>

          
          <div class="method-heading">
            <span class="method-name">Proxy</span><span class="method-args">(p_addr, p_port = nil, p_user = nil, p_pass = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Creates an HTTP proxy class which behaves like Net::HTTP, but performs all
access via the specified proxy.</p>

<p>The arguments are the DNS name or IP address of the proxy host, the port to
use to access the proxy, and a username and password if authorization is
required to use the proxy.</p>

<p>You can replace any use of the Net::HTTP class with use of the proxy class
created.</p>

<p>If <tt>p_addr</tt> is nil, this method returns self (a Net::HTTP object).</p>

<pre># Example
proxy_class = Net::HTTP::Proxy('proxy.example.com', 8080)

proxy_class.start('www.ruby-lang.org') {|http|
  # connecting proxy.foo.org:8080
}</pre>

<p>You may use them to work with authorization-enabled proxies:</p>

<pre>proxy_host = 'your.proxy.example'
proxy_port = 8080
proxy_user = 'user'
proxy_pass = 'pass'

proxy = Net::HTTP::Proxy(proxy_host, proxy_port, proxy_user, proxy_pass)
proxy.start('www.example.com') { |http|
  # always connect to your.proxy.example:8080 using specified username
  # and password
}</pre>

<p>Note that net/http does not use the HTTP_PROXY environment variable. If you
want to use a proxy, you must set it explicitly.</p>
            

            
            <div class="method-source-code" id="Proxy-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 879</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-constant">Proxy</span>(<span class="ruby-identifier">p_addr</span>, <span class="ruby-identifier">p_port</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_user</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_pass</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">p_addr</span>
  <span class="ruby-identifier">delta</span> = <span class="ruby-constant">ProxyDelta</span>
  <span class="ruby-identifier">proxyclass</span> = <span class="ruby-constant">Class</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>)
  <span class="ruby-identifier">proxyclass</span>.<span class="ruby-identifier">module_eval</span> {
    <span class="ruby-identifier">include</span> <span class="ruby-identifier">delta</span>
    <span class="ruby-comment"># with proxy</span>
    <span class="ruby-ivar">@is_proxy_class</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-ivar">@proxy_address</span> = <span class="ruby-identifier">p_addr</span>
    <span class="ruby-ivar">@proxy_port</span>    = <span class="ruby-identifier">p_port</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">default_port</span>()
    <span class="ruby-ivar">@proxy_user</span>    = <span class="ruby-identifier">p_user</span>
    <span class="ruby-ivar">@proxy_pass</span>    = <span class="ruby-identifier">p_pass</span>
  }
  <span class="ruby-identifier">proxyclass</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- Proxy-source -->
            
          </div>

          

          
        </div><!-- Proxy-method -->

      
        <div id="default_port-method" class="method-detail ">
          <a name="method-c-default_port"></a>

          
          <div class="method-heading">
            <span class="method-name">default_port</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The default port to use for HTTP requests; defaults to 80.</p>
            

            
            <div class="method-source-code" id="default_port-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 492</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">default_port</span>
  <span class="ruby-identifier">http_default_port</span>()
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- default_port-source -->
            
          </div>

          

          
        </div><!-- default_port-method -->

      
        <div id="get-method" class="method-detail ">
          <a name="method-c-get"></a>

          
          <div class="method-heading">
            <span class="method-name">get</span><span class="method-args">(uri_or_host, path = nil, port = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a GET request to the target and returns the HTTP response as a
string.  The target can either be specified as (<tt>uri</tt>), or as
(<tt>host</tt>, <tt>path</tt>, <tt>port</tt> = 80); so:</p>

<pre>print Net::HTTP.get(URI('http://www.example.com/index.html'))</pre>

<p>or:</p>

<pre>print Net::HTTP.get('www.example.com', '/index.html')</pre>
            

            
            <div class="method-source-code" id="get-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 430</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">get</span>(<span class="ruby-identifier">uri_or_host</span>, <span class="ruby-identifier">path</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">get_response</span>(<span class="ruby-identifier">uri_or_host</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">port</span>).<span class="ruby-identifier">body</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- get-source -->
            
          </div>

          

          
        </div><!-- get-method -->

      
        <div id="get_print-method" class="method-detail ">
          <a name="method-c-get_print"></a>

          
          <div class="method-heading">
            <span class="method-name">get_print</span><span class="method-args">(uri_or_host, path = nil, port = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Gets the body text from the target and outputs it to $stdout.  The target
can either be specified as (<tt>uri</tt>), or as (<tt>host</tt>,
<tt>path</tt>, <tt>port</tt> = 80); so:</p>

<pre>Net::HTTP.get_print URI('http://www.example.com/index.html')</pre>

<p>or:</p>

<pre>Net::HTTP.get_print 'www.example.com', '/index.html'</pre>
            

            
            <div class="method-source-code" id="get_print-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 411</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">get_print</span>(<span class="ruby-identifier">uri_or_host</span>, <span class="ruby-identifier">path</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">get_response</span>(<span class="ruby-identifier">uri_or_host</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">port</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">res</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">res</span>.<span class="ruby-identifier">read_body</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">chunk</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">$stdout</span>.<span class="ruby-identifier">print</span> <span class="ruby-identifier">chunk</span>
    <span class="ruby-keyword">end</span>
  }
  <span class="ruby-keyword">nil</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- get_print-source -->
            
          </div>

          

          
        </div><!-- get_print-method -->

      
        <div id="get_response-method" class="method-detail ">
          <a name="method-c-get_response"></a>

          
          <div class="method-heading">
            <span class="method-name">get_response</span><span class="method-args">(uri_or_host, path = nil, port = nil, &amp;block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a GET request to the target and returns the HTTP response as a <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a> object.  The target can
either be specified as (<tt>uri</tt>), or as (<tt>host</tt>, <tt>path</tt>,
<tt>port</tt> = 80); so:</p>

<pre>res = Net::HTTP.get_response(URI('http://www.example.com/index.html'))
print res.body</pre>

<p>or:</p>

<pre>res = Net::HTTP.get_response('www.example.com', '/index.html')
print res.body</pre>
            

            
            <div class="method-source-code" id="get_response-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 446</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">get_response</span>(<span class="ruby-identifier">uri_or_host</span>, <span class="ruby-identifier">path</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">path</span>
    <span class="ruby-identifier">host</span> = <span class="ruby-identifier">uri_or_host</span>
    <span class="ruby-identifier">new</span>(<span class="ruby-identifier">host</span>, <span class="ruby-identifier">port</span> <span class="ruby-operator">||</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">default_port</span>).<span class="ruby-identifier">start</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request_get</span>(<span class="ruby-identifier">path</span>, &amp;<span class="ruby-identifier">block</span>)
    }
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">uri</span> = <span class="ruby-identifier">uri_or_host</span>
    <span class="ruby-identifier">new</span>(<span class="ruby-identifier">uri</span>.<span class="ruby-identifier">hostname</span>, <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">port</span>).<span class="ruby-identifier">start</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request_get</span>(<span class="ruby-identifier">uri</span>.<span class="ruby-identifier">request_uri</span>, &amp;<span class="ruby-identifier">block</span>)
    }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- get_response-source -->
            
          </div>

          

          
        </div><!-- get_response-method -->

      
        <div id="http_default_port-method" class="method-detail ">
          <a name="method-c-http_default_port"></a>

          
          <div class="method-heading">
            <span class="method-name">http_default_port</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The default port to use for HTTP requests; defaults to 80.</p>
            

            
            <div class="method-source-code" id="http_default_port-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 497</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">http_default_port</span>
  <span class="ruby-value">80</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- http_default_port-source -->
            
          </div>

          

          
        </div><!-- http_default_port-method -->

      
        <div id="https_default_port-method" class="method-detail ">
          <a name="method-c-https_default_port"></a>

          
          <div class="method-heading">
            <span class="method-name">https_default_port</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>The default port to use for HTTPS requests; defaults to 443.</p>
            

            
            <div class="method-source-code" id="https_default_port-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 502</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">https_default_port</span>
  <span class="ruby-value">443</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- https_default_port-source -->
            
          </div>

          

          
        </div><!-- https_default_port-method -->

      
        <div id="is_version_1_2-3F-method" class="method-detail method-alias">
          <a name="method-c-is_version_1_2-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_version_1_2?</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-version_1_2-3F">version_1_2?</a>
          </div>
          
        </div><!-- is_version_1_2-3F-method -->

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          <div class="method-heading">
            <span class="method-name">new</span><span class="method-args">(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Creates a new Net::HTTP object without opening a TCP connection or HTTP
session. The <tt>address</tt> should be a DNS hostname or IP address. If
<tt>p_addr</tt> is given, creates a Net::HTTP object with proxy support.</p>
            

            
            <div class="method-source-code" id="new-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 568</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">address</span>, <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_addr</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_port</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_user</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">p_pass</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-constant">Proxy</span>(<span class="ruby-identifier">p_addr</span>, <span class="ruby-identifier">p_port</span>, <span class="ruby-identifier">p_user</span>, <span class="ruby-identifier">p_pass</span>).<span class="ruby-identifier">newobj</span>(<span class="ruby-identifier">address</span>, <span class="ruby-identifier">port</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- new-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-newobj">newobj</a>
          </div>
          

          
        </div><!-- new-method -->

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          <div class="method-heading">
            <span class="method-name">new</span><span class="method-args">(address, port = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Creates a new Net::HTTP object for the specified server address, without
opening the TCP connection or initializing the HTTP session. The
<tt>address</tt> should be a DNS hostname or IP address.</p>
            

            
            <div class="method-source-code" id="new-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 575</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">address</span>, <span class="ruby-identifier">port</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-ivar">@address</span> = <span class="ruby-identifier">address</span>
  <span class="ruby-ivar">@port</span>    = (<span class="ruby-identifier">port</span> <span class="ruby-operator">||</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">default_port</span>)
  <span class="ruby-ivar">@curr_http_version</span> = <span class="ruby-constant">HTTPVersion</span>
  <span class="ruby-ivar">@no_keepalive_server</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@close_on_empty_response</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@socket</span>  = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@started</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@open_timeout</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@read_timeout</span> = <span class="ruby-value">60</span>
  <span class="ruby-ivar">@continue_timeout</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@debug_output</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@use_ssl</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-ivar">@ssl_context</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@enable_post_connection_check</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-ivar">@compression</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-ivar">@sspi_enabled</span> = <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-constant">SSL_ATTRIBUTES</span>)
    <span class="ruby-constant">SSL_ATTRIBUTES</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">name</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">instance_variable_set</span> <span class="ruby-node">"@#{name}"</span>, <span class="ruby-keyword">nil</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
        <div id="newobj-method" class="method-detail method-alias">
          <a name="method-c-newobj"></a>

          
          <div class="method-heading">
            <span class="method-name">newobj</span><span class="method-args">(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-new">new</a>
          </div>
          
        </div><!-- newobj-method -->

      
        <div id="post_form-method" class="method-detail ">
          <a name="method-c-post_form"></a>

          
          <div class="method-heading">
            <span class="method-name">post_form</span><span class="method-args">(url, params)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Posts HTML form data to the specified URI object. The form data must be
provided as a Hash mapping from String to String. Example:</p>

<pre>{ "cmd" =&gt; "search", "q" =&gt; "ruby", "max" =&gt; "50" }</pre>

<p>This method also does Basic Authentication iff <tt>url</tt>.user exists.
But userinfo for authentication is deprecated (RFC3986). So this feature
will be removed.</p>

<p>Example:</p>

<pre>require 'net/http'
require 'uri'

HTTP.post_form URI('http://www.example.com/search.cgi'),
               { "q" =&gt; "ruby", "max" =&gt; "50" }</pre>
            

            
            <div class="method-source-code" id="post_form-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 478</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">post_form</span>(<span class="ruby-identifier">url</span>, <span class="ruby-identifier">params</span>)
  <span class="ruby-identifier">req</span> = <span class="ruby-constant">Post</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">request_uri</span>)
  <span class="ruby-identifier">req</span>.<span class="ruby-identifier">form_data</span> = <span class="ruby-identifier">params</span>
  <span class="ruby-identifier">req</span>.<span class="ruby-identifier">basic_auth</span> <span class="ruby-identifier">url</span>.<span class="ruby-identifier">user</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">password</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">url</span>.<span class="ruby-identifier">user</span>
  <span class="ruby-identifier">new</span>(<span class="ruby-identifier">url</span>.<span class="ruby-identifier">hostname</span>, <span class="ruby-identifier">url</span>.<span class="ruby-identifier">port</span>).<span class="ruby-identifier">start</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">http</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">http</span>.<span class="ruby-identifier">request</span>(<span class="ruby-identifier">req</span>)
  }
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- post_form-source -->
            
          </div>

          

          
        </div><!-- post_form-method -->

      
        <div id="proxy_class-3F-method" class="method-detail ">
          <a name="method-c-proxy_class-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy_class?</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>returns true if self is a class which was created by HTTP::Proxy.</p>
            

            
            <div class="method-source-code" id="proxy_class-3F-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 897</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy_class?</span>
  <span class="ruby-ivar">@is_proxy_class</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy_class-3F-source -->
            
          </div>

          

          
        </div><!-- proxy_class-3F-method -->

      
        <div id="start-method" class="method-detail ">
          <a name="method-c-start"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">start(address, port, p_addr, p_port, p_user, p_pass, &amp;block)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">start(address, port=nil, p_addr=nil, p_port=nil, p_user=nil, p_pass=nil, opt, &amp;block)</span>
            
          </div>
          
          

          <div class="method-description">
            
            <p>Creates a new Net::HTTP object, then additionally opens the TCP connection
and HTTP session.</p>

<p>Arguments are the following:</p>
<table class="rdoc-list"><tbody><tr><td class="rdoc-term"><p><em>address</em> </p></td>
<td>
<p>hostname or IP address of the server</p>
</td></tr><tr><td class="rdoc-term"><p><em>port</em>    </p></td>
<td>
<p>port of the server</p>
</td></tr><tr><td class="rdoc-term"><p><em>p_addr</em>  </p></td>
<td>
<p>address of proxy</p>
</td></tr><tr><td class="rdoc-term"><p><em>p_port</em>  </p></td>
<td>
<p>port of proxy</p>
</td></tr><tr><td class="rdoc-term"><p><em>p_user</em>  </p></td>
<td>
<p>user of proxy</p>
</td></tr><tr><td class="rdoc-term"><p><em>p_pass</em>  </p></td>
<td>
<p>pass of proxy</p>
</td></tr><tr><td class="rdoc-term"><p><em>opt</em>     </p></td>
<td>
<p>optional hash</p>
</td></tr></tbody></table>

<p><em>opt</em> sets following values by its accessor. The keys are <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-ca_file">ca_file</a>, <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-ca_path">ca_path</a>, cert, <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-cert_store">cert_store</a>, ciphers, <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-close_on_empty_response">close_on_empty_response</a>,
key, <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-open_timeout">open_timeout</a>, <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-read_timeout">read_timeout</a>, <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-ssl_timeout">ssl_timeout</a>, <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-ssl_version">ssl_version</a>, use_ssl, <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-verify_callback">verify_callback</a>, <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-verify_depth">verify_depth</a> and verify_mode.
If you set :use_ssl as true, you can use https and default value of <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-verify_mode">verify_mode</a> is set as
OpenSSL::SSL::VERIFY_PEER.</p>

<p>If the optional block is given, the newly created Net::HTTP object is
passed to it and closed when the block finishes.  In this case, the return
value of this method is the return value of the block.  If no block is
given, the return value of this method is the newly created Net::HTTP
object itself, and the caller is responsible for closing it upon completion
using the finish() method.</p>
            

            
            <div class="method-source-code" id="start-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 540</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">start</span>(<span class="ruby-identifier">address</span>, *<span class="ruby-identifier">arg</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +http+</span>
  <span class="ruby-identifier">arg</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">opt</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">try_convert</span>(<span class="ruby-identifier">arg</span>[<span class="ruby-value">-1</span>])
  <span class="ruby-identifier">port</span>, <span class="ruby-identifier">p_addr</span>, <span class="ruby-identifier">p_port</span>, <span class="ruby-identifier">p_user</span>, <span class="ruby-identifier">p_pass</span> = *<span class="ruby-identifier">arg</span>
  <span class="ruby-identifier">port</span> = <span class="ruby-identifier">https_default_port</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">port</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">opt</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">opt</span>[<span class="ruby-value">:use_ssl</span>]
  <span class="ruby-identifier">http</span> = <span class="ruby-identifier">new</span>(<span class="ruby-identifier">address</span>, <span class="ruby-identifier">port</span>, <span class="ruby-identifier">p_addr</span>, <span class="ruby-identifier">p_port</span>, <span class="ruby-identifier">p_user</span>, <span class="ruby-identifier">p_pass</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opt</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">opt</span>[<span class="ruby-value">:use_ssl</span>]
      <span class="ruby-identifier">opt</span> = {<span class="ruby-identifier">verify_mode</span><span class="ruby-operator">:</span> <span class="ruby-constant">OpenSSL</span><span class="ruby-operator">::</span><span class="ruby-constant">SSL</span><span class="ruby-operator">::</span><span class="ruby-constant">VERIFY_PEER</span>}.<span class="ruby-identifier">update</span>(<span class="ruby-identifier">opt</span>)
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">http</span>.<span class="ruby-identifier">methods</span>.<span class="ruby-identifier">grep</span>(<span class="ruby-regexp">/\A(\w+)=\z/</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">meth</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">key</span> = <span class="ruby-node">$1</span>.<span class="ruby-identifier">to_sym</span>
      <span class="ruby-identifier">opt</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">key</span>) <span class="ruby-keyword">or</span> <span class="ruby-keyword">next</span>
      <span class="ruby-identifier">http</span>.<span class="ruby-identifier">__send__</span>(<span class="ruby-identifier">meth</span>, <span class="ruby-identifier">opt</span>[<span class="ruby-identifier">key</span>])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">http</span>.<span class="ruby-identifier">start</span>(&amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- start-source -->
            
          </div>

          

          
        </div><!-- start-method -->

      
        <div id="version_1_2-method" class="method-detail ">
          <a name="method-c-version_1_2"></a>

          
          <div class="method-heading">
            <span class="method-name">version_1_2</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Turns on net/http 1.2 (ruby 1.8) features. Defaults to ON in ruby 1.8 or
later.</p>
            

            
            <div class="method-source-code" id="version_1_2-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 377</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">version_1_2</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- version_1_2-source -->
            
          </div>

          

          
        </div><!-- version_1_2-method -->

      
        <div id="version_1_2-3F-method" class="method-detail ">
          <a name="method-c-version_1_2-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">version_1_2?</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns true if net/http is in version 1.2 mode. Defaults to true.</p>
            

            
            <div class="method-source-code" id="version_1_2-3F-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 383</span>
<span class="ruby-keyword">def</span> <span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">version_1_2?</span>
  <span class="ruby-keyword">true</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- version_1_2-3F-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-c-is_version_1_2-3F">is_version_1_2?</a>
          </div>
          

          
        </div><!-- version_1_2-3F-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="active-3F-method" class="method-detail method-alias">
          <a name="method-i-active-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">active?</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-started-3F">started?</a>
          </div>
          
        </div><!-- active-3F-method -->

      
        <div id="continue_timeout-3D-method" class="method-detail ">
          <a name="method-i-continue_timeout-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">continue_timeout=</span><span class="method-args">(sec)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Setter for the <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-continue_timeout">continue_timeout</a>
attribute.</p>
            

            
            <div class="method-source-code" id="continue_timeout-3D-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 646</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">continue_timeout=</span>(<span class="ruby-identifier">sec</span>)
  <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">continue_timeout</span> = <span class="ruby-identifier">sec</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@socket</span>
  <span class="ruby-ivar">@continue_timeout</span> = <span class="ruby-identifier">sec</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- continue_timeout-3D-source -->
            
          </div>

          

          
        </div><!-- continue_timeout-3D-method -->

      
        <div id="copy-method" class="method-detail ">
          <a name="method-i-copy"></a>

          
          <div class="method-heading">
            <span class="method-name">copy</span><span class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a COPY request to the <tt>path</tt> and gets a response, as an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="copy-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1153</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">copy</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Copy</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- copy-source -->
            
          </div>

          

          
        </div><!-- copy-method -->

      
        <div id="delete-method" class="method-detail ">
          <a name="method-i-delete"></a>

          
          <div class="method-heading">
            <span class="method-name">delete</span><span class="method-args">(path, initheader = {'Depth' =&gt; 'Infinity'})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a DELETE request to the <tt>path</tt> and gets a response, as an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="delete-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">delete</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = {<span class="ruby-string">'Depth'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'Infinity'</span>})
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Delete</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- delete-source -->
            
          </div>

          

          
        </div><!-- delete-method -->

      
        <div id="finish-method" class="method-detail ">
          <a name="method-i-finish"></a>

          
          <div class="method-heading">
            <span class="method-name">finish</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Finishes the HTTP session and closes the TCP connection. Raises IOError if
the session has not been started.</p>
            

            
            <div class="method-source-code" id="finish-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 819</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">finish</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">IOError</span>, <span class="ruby-string">'HTTP session not yet started'</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">started?</span>
  <span class="ruby-identifier">do_finish</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- finish-source -->
            
          </div>

          

          
        </div><!-- finish-method -->

      
        <div id="get-method" class="method-detail ">
          <a name="method-i-get"></a>

          
          <div class="method-heading">
            <span class="method-name">get</span><span class="method-args">(path, initheader = {}, dest = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Gets data from <tt>path</tt> on the connected-to host. <tt>initheader</tt>
must be a Hash like { ‘Accept’ =&gt; ‘<b>/</b>’, … }, and it defaults to an
empty hash. If <tt>initheader</tt> doesn’t have the key ‘accept-encoding’,
then a value of “gzip;q=1.0,deflate;q=0.6,identity;q=0.3” is used, so that
gzip compression is used in preference to deflate compression, which is
used in preference to no compression. Ruby doesn’t have libraries to
support the compress (Lempel-Ziv) compression, so that is not supported. 
The intent of this is to reduce bandwidth by default.   If this routine
sets up compression, then it does the decompression also, removing the
header as well to prevent confusion.  Otherwise it leaves the body as it
found it.</p>

<p>This method returns a <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a>
object.</p>

<p>If called with a block, yields each fragment of the entity body in turn as
a string as it is read from the socket.  Note that in this case, the
returned response object will <b>not</b> contain a (meaningful) body.</p>

<p><tt>dest</tt> argument is obsolete. It still works but you must not use it.</p>

<p>This method never raises an exception.</p>

<pre>response = http.get('/index.html')

# using block
File.open('result.txt', 'w') {|f|
  http.get('/~foo/') do |str|
    f.write str
  end
}</pre>
            

            
            <div class="method-source-code" id="get-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1016</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = {}, <span class="ruby-identifier">dest</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +body_segment+</span>
  <span class="ruby-identifier">res</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-constant">HAVE_ZLIB</span>
    <span class="ruby-keyword">unless</span>  <span class="ruby-identifier">initheader</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">any?</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span>.<span class="ruby-identifier">downcase</span> <span class="ruby-operator">==</span> <span class="ruby-string">"accept-encoding"</span>}
      <span class="ruby-identifier">initheader</span> = <span class="ruby-identifier">initheader</span>.<span class="ruby-identifier">merge</span>({
        <span class="ruby-string">"accept-encoding"</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">"gzip;q=1.0,deflate;q=0.6,identity;q=0.3"</span>
      })
      <span class="ruby-ivar">@compression</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Get</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>)) {<span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-string">"content-encoding"</span>) <span class="ruby-keyword">and</span> <span class="ruby-ivar">@compression</span>
      <span class="ruby-ivar">@compression</span> = <span class="ruby-keyword">nil</span> <span class="ruby-comment"># Clear it till next set.</span>
      <span class="ruby-identifier">the_body</span> = <span class="ruby-identifier">r</span>.<span class="ruby-identifier">read_body</span> <span class="ruby-identifier">dest</span>, &amp;<span class="ruby-identifier">block</span>
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">r</span>[<span class="ruby-string">"content-encoding"</span>]
      <span class="ruby-keyword">when</span> <span class="ruby-string">"gzip"</span>
        <span class="ruby-identifier">r</span>.<span class="ruby-identifier">body</span>= <span class="ruby-constant">Zlib</span><span class="ruby-operator">::</span><span class="ruby-constant">GzipReader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">StringIO</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">the_body</span>), <span class="ruby-identifier">encoding</span><span class="ruby-operator">:</span> <span class="ruby-string">"ASCII-8BIT"</span>).<span class="ruby-identifier">read</span>
        <span class="ruby-identifier">r</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">"content-encoding"</span>)
      <span class="ruby-keyword">when</span> <span class="ruby-string">"deflate"</span>
        <span class="ruby-identifier">r</span>.<span class="ruby-identifier">body</span>= <span class="ruby-constant">Zlib</span><span class="ruby-operator">::</span><span class="ruby-constant">Inflate</span>.<span class="ruby-identifier">inflate</span>(<span class="ruby-identifier">the_body</span>);
        <span class="ruby-identifier">r</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-string">"content-encoding"</span>)
      <span class="ruby-keyword">when</span> <span class="ruby-string">"identity"</span>
        ; <span class="ruby-comment"># nothing needed</span>
      <span class="ruby-keyword">else</span>
        ; <span class="ruby-comment"># Don't do anything dramatic, unless we need to later</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">r</span>.<span class="ruby-identifier">read_body</span> <span class="ruby-identifier">dest</span>, &amp;<span class="ruby-identifier">block</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">res</span> = <span class="ruby-identifier">r</span>
  }
  <span class="ruby-identifier">res</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- get-source -->
            
          </div>

          

          
        </div><!-- get-method -->

      
        <div id="get2-method" class="method-detail method-alias">
          <a name="method-i-get2"></a>

          
          <div class="method-heading">
            <span class="method-name">get2</span><span class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-request_get">request_get</a>
          </div>
          
        </div><!-- get2-method -->

      
        <div id="head-method" class="method-detail ">
          <a name="method-i-head"></a>

          
          <div class="method-heading">
            <span class="method-name">head</span><span class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Gets only the header from <tt>path</tt> on the connected-to host.
<tt>header</tt> is a Hash like { ‘Accept’ =&gt; ‘<b>/</b>’, … }.</p>

<p>This method returns a <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a>
object.</p>

<p>This method never raises an exception.</p>

<pre>response = nil
Net::HTTP.start('some.www.server', 80) {|http|
  response = http.head('/index.html')
}
p response['content-type']</pre>
            

            
            <div class="method-source-code" id="head-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1063</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">head</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Head</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- head-source -->
            
          </div>

          

          
        </div><!-- head-method -->

      
        <div id="head2-method" class="method-detail method-alias">
          <a name="method-i-head2"></a>

          
          <div class="method-heading">
            <span class="method-name">head2</span><span class="method-args">(path, initheader = nil, &amp;block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-request_head">request_head</a>
          </div>
          
        </div><!-- head2-method -->

      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          <div class="method-heading">
            <span class="method-name">inspect</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="inspect-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 599</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inspect</span>
  <span class="ruby-node">"#&lt;#{self.class} #{@address}:#{@port} open=#{started?}&gt;"</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- inspect-source -->
            
          </div>

          

          
        </div><!-- inspect-method -->

      
        <div id="lock-method" class="method-detail ">
          <a name="method-i-lock"></a>

          
          <div class="method-heading">
            <span class="method-name">lock</span><span class="method-args">(path, body, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a LOCK request to the <tt>path</tt> and gets a response, as an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="lock-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1117</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">lock</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Lock</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- lock-source -->
            
          </div>

          

          
        </div><!-- lock-method -->

      
        <div id="mkcol-method" class="method-detail ">
          <a name="method-i-mkcol"></a>

          
          <div class="method-heading">
            <span class="method-name">mkcol</span><span class="method-args">(path, body = nil, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a MKCOL request to the <tt>path</tt> and gets a response, as an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="mkcol-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1159</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">mkcol</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">body</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Mkcol</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- mkcol-source -->
            
          </div>

          

          
        </div><!-- mkcol-method -->

      
        <div id="move-method" class="method-detail ">
          <a name="method-i-move"></a>

          
          <div class="method-heading">
            <span class="method-name">move</span><span class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a MOVE request to the <tt>path</tt> and gets a response, as an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="move-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1147</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">move</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Move</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- move-source -->
            
          </div>

          

          
        </div><!-- move-method -->

      
        <div id="options-method" class="method-detail ">
          <a name="method-i-options"></a>

          
          <div class="method-heading">
            <span class="method-name">options</span><span class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a OPTIONS request to the <tt>path</tt> and gets a response, as an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="options-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1129</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">options</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Options</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- options-source -->
            
          </div>

          

          
        </div><!-- options-method -->

      
        <div id="patch-method" class="method-detail ">
          <a name="method-i-patch"></a>

          
          <div class="method-heading">
            <span class="method-name">patch</span><span class="method-args">(path, data, initheader = nil, dest = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a PATCH request to the <tt>path</tt> and gets a response, as an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="patch-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">patch</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">dest</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +body_segment+</span>
  <span class="ruby-identifier">send_entity</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">initheader</span>, <span class="ruby-identifier">dest</span>, <span class="ruby-constant">Patch</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- patch-source -->
            
          </div>

          

          
        </div><!-- patch-method -->

      
        <div id="peer_cert-method" class="method-detail ">
          <a name="method-i-peer_cert"></a>

          
          <div class="method-heading">
            <span class="method-name">peer_cert</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns the X.509 certificates the server presented.</p>
            

            
            <div class="method-source-code" id="peer_cert-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 724</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">peer_cert</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">use_ssl?</span> <span class="ruby-keyword">or</span> <span class="ruby-keyword">not</span> <span class="ruby-ivar">@socket</span>
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">io</span>.<span class="ruby-identifier">peer_cert</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- peer_cert-source -->
            
          </div>

          

          
        </div><!-- peer_cert-method -->

      
        <div id="post-method" class="method-detail ">
          <a name="method-i-post"></a>

          
          <div class="method-heading">
            <span class="method-name">post</span><span class="method-args">(path, data, initheader = nil, dest = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Posts <tt>data</tt> (must be a String) to <tt>path</tt>. <tt>header</tt>
must be a Hash like { ‘Accept’ =&gt; ‘<b>/</b>’, … }.</p>

<p>This method returns a <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a>
object.</p>

<p>If called with a block, yields each fragment of the entity body in turn as
a string as it is read from the socket.  Note that in this case, the
returned response object will <b>not</b> contain a (meaningful) body.</p>

<p><tt>dest</tt> argument is obsolete. It still works but you must not use it.</p>

<p>This method never raises exception.</p>

<pre>response = http.post('/cgi-bin/search.rb', 'query=foo')

# using block
File.open('result.txt', 'w') {|f|
  http.post('/cgi-bin/search.rb', 'query=foo') do |str|
    f.write str
  end
}</pre>

<p>You should set Content-Type: header field for POST. If no Content-Type:
field given, this method uses “application/x-www-form-urlencoded” by
default.</p>
            

            
            <div class="method-source-code" id="post-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1095</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">post</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">dest</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +body_segment+</span>
  <span class="ruby-identifier">send_entity</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">initheader</span>, <span class="ruby-identifier">dest</span>, <span class="ruby-constant">Post</span>, &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- post-source -->
            
          </div>

          

          
        </div><!-- post-method -->

      
        <div id="post2-method" class="method-detail method-alias">
          <a name="method-i-post2"></a>

          
          <div class="method-heading">
            <span class="method-name">post2</span><span class="method-args">(path, data, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-request_post">request_post</a>
          </div>
          
        </div><!-- post2-method -->

      
        <div id="propfind-method" class="method-detail ">
          <a name="method-i-propfind"></a>

          
          <div class="method-heading">
            <span class="method-name">propfind</span><span class="method-args">(path, body = nil, initheader = {'Depth' =&gt; '0'})</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a PROPFIND request to the <tt>path</tt> and gets a response, as an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="propfind-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1135</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">propfind</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">body</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">initheader</span> = {<span class="ruby-string">'Depth'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-string">'0'</span>})
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Propfind</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- propfind-source -->
            
          </div>

          

          
        </div><!-- propfind-method -->

      
        <div id="proppatch-method" class="method-detail ">
          <a name="method-i-proppatch"></a>

          
          <div class="method-heading">
            <span class="method-name">proppatch</span><span class="method-args">(path, body, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a PROPPATCH request to the <tt>path</tt> and gets a response, as an
<a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="proppatch-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1111</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proppatch</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Proppatch</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proppatch-source -->
            
          </div>

          

          
        </div><!-- proppatch-method -->

      
        <div id="proxy-3F-method" class="method-detail ">
          <a name="method-i-proxy-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy?</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>True if self is a HTTP proxy class.</p>
            

            
            <div class="method-source-code" id="proxy-3F-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 916</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy?</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">proxy_class?</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy-3F-source -->
            
          </div>

          

          
        </div><!-- proxy-3F-method -->

      
        <div id="proxy_address-method" class="method-detail ">
          <a name="method-i-proxy_address"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy_address</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>A convenience method for accessing value of <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy_address">proxy_address</a> from Net::HTTP.</p>
            

            
            <div class="method-source-code" id="proxy_address-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 921</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy_address</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">proxy_address</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy_address-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxyaddr">proxyaddr</a>
          </div>
          

          
        </div><!-- proxy_address-method -->

      
        <div id="proxy_pass-method" class="method-detail ">
          <a name="method-i-proxy_pass"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy_pass</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>A convenience method for accessing value of <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy_pass">proxy_pass</a> from Net::HTTP.</p>
            

            
            <div class="method-source-code" id="proxy_pass-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 936</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy_pass</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">proxy_pass</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy_pass-source -->
            
          </div>

          

          
        </div><!-- proxy_pass-method -->

      
        <div id="proxy_port-method" class="method-detail ">
          <a name="method-i-proxy_port"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy_port</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>A convenience method for accessing value of <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy_port">proxy_port</a> from Net::HTTP.</p>
            

            
            <div class="method-source-code" id="proxy_port-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 926</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy_port</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">proxy_port</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy_port-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxyport">proxyport</a>
          </div>
          

          
        </div><!-- proxy_port-method -->

      
        <div id="proxy_user-method" class="method-detail ">
          <a name="method-i-proxy_user"></a>

          
          <div class="method-heading">
            <span class="method-name">proxy_user</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>A convenience method for accessing value of <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy_user">proxy_user</a> from Net::HTTP.</p>
            

            
            <div class="method-source-code" id="proxy_user-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 931</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">proxy_user</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">proxy_user</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- proxy_user-source -->
            
          </div>

          

          
        </div><!-- proxy_user-method -->

      
        <div id="proxyaddr-method" class="method-detail method-alias">
          <a name="method-i-proxyaddr"></a>

          
          <div class="method-heading">
            <span class="method-name">proxyaddr</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy_address">proxy_address</a>
          </div>
          
        </div><!-- proxyaddr-method -->

      
        <div id="proxyport-method" class="method-detail method-alias">
          <a name="method-i-proxyport"></a>

          
          <div class="method-heading">
            <span class="method-name">proxyport</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-proxy_port">proxy_port</a>
          </div>
          
        </div><!-- proxyport-method -->

      
        <div id="read_timeout-3D-method" class="method-detail ">
          <a name="method-i-read_timeout-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">read_timeout=</span><span class="method-args">(sec)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Setter for the <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#attribute-i-read_timeout">read_timeout</a> attribute.</p>
            

            
            <div class="method-source-code" id="read_timeout-3D-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 636</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">read_timeout=</span>(<span class="ruby-identifier">sec</span>)
  <span class="ruby-ivar">@socket</span>.<span class="ruby-identifier">read_timeout</span> = <span class="ruby-identifier">sec</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@socket</span>
  <span class="ruby-ivar">@read_timeout</span> = <span class="ruby-identifier">sec</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- read_timeout-3D-source -->
            
          </div>

          

          
        </div><!-- read_timeout-3D-method -->

      
        <div id="request-method" class="method-detail ">
          <a name="method-i-request"></a>

          
          <div class="method-heading">
            <span class="method-name">request</span><span class="method-args">(req, body = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPRequest.html">HTTPRequest</a> object <tt>req</tt> to
the HTTP server.</p>

<p>If <tt>req</tt> is a <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Post.html">Net::HTTP::Post</a> or <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Put.html">Net::HTTP::Put</a> request containing data, the data
is also sent. Providing data for a <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Head.html">Net::HTTP::Head</a> or <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP/Get.html">Net::HTTP::Get</a> request results in an
ArgumentError.</p>

<p>Returns an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>

<p>When called with a block, passes an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object to the block. The body of
the response will not have been read yet; the block can process it using <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html#method-i-read_body">HTTPResponse#read_body</a>, if
desired.</p>

<p>This method never raises Net::* exceptions.</p>
            

            
            <div class="method-source-code" id="request-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1282</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">request</span>(<span class="ruby-identifier">req</span>, <span class="ruby-identifier">body</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)  <span class="ruby-comment"># :yield: +response+</span>
  <span class="ruby-keyword">unless</span> <span class="ruby-identifier">started?</span>
    <span class="ruby-identifier">start</span> {
      <span class="ruby-identifier">req</span>[<span class="ruby-string">'connection'</span>] <span class="ruby-operator">||=</span> <span class="ruby-string">'close'</span>
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">request</span>(<span class="ruby-identifier">req</span>, <span class="ruby-identifier">body</span>, &amp;<span class="ruby-identifier">block</span>)
    }
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">proxy_user</span>()
    <span class="ruby-identifier">req</span>.<span class="ruby-identifier">proxy_basic_auth</span> <span class="ruby-identifier">proxy_user</span>(), <span class="ruby-identifier">proxy_pass</span>() <span class="ruby-keyword">unless</span> <span class="ruby-identifier">use_ssl?</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">req</span>.<span class="ruby-identifier">set_body_internal</span> <span class="ruby-identifier">body</span>
  <span class="ruby-identifier">res</span> = <span class="ruby-identifier">transport_request</span>(<span class="ruby-identifier">req</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">sspi_auth?</span>(<span class="ruby-identifier">res</span>)
    <span class="ruby-identifier">sspi_auth</span>(<span class="ruby-identifier">req</span>)
    <span class="ruby-identifier">res</span> = <span class="ruby-identifier">transport_request</span>(<span class="ruby-identifier">req</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">res</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- request-source -->
            
          </div>

          

          
        </div><!-- request-method -->

      
        <div id="request_get-method" class="method-detail ">
          <a name="method-i-request_get"></a>

          
          <div class="method-heading">
            <span class="method-name">request_get</span><span class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a GET request to the <tt>path</tt>. Returns the response as a <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a> object.</p>

<p>When called with a block, passes an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object to the block. The body of
the response will not have been read yet; the block can process it using <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html#method-i-read_body">HTTPResponse#read_body</a>, if
desired.</p>

<p>Returns the response.</p>

<p>This method never raises Net::* exceptions.</p>

<pre>response = http.request_get('/index.html')
# The entity body is already read in this case.
p response['content-type']
puts response.body

# Using a block
http.request_get('/index.html') {|response|
  p response['content-type']
  response.read_body do |str|   # read body now
    print str
  end
}</pre>
            

            
            <div class="method-source-code" id="request_get-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1194</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">request_get</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +response+</span>
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Get</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- request_get-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-get2">get2</a>
          </div>
          

          
        </div><!-- request_get-method -->

      
        <div id="request_head-method" class="method-detail ">
          <a name="method-i-request_head"></a>

          
          <div class="method-heading">
            <span class="method-name">request_head</span><span class="method-args">(path, initheader = nil, &amp;block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a HEAD request to the <tt>path</tt> and returns the response as a <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a> object.</p>

<p>Returns the response.</p>

<p>This method never raises Net::* exceptions.</p>

<pre>response = http.request_head('/index.html')
p response['content-type']</pre>
            

            
            <div class="method-source-code" id="request_head-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1208</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">request_head</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Head</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), &amp;<span class="ruby-identifier">block</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- request_head-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-head2">head2</a>
          </div>
          

          
        </div><!-- request_head-method -->

      
        <div id="request_post-method" class="method-detail ">
          <a name="method-i-request_post"></a>

          
          <div class="method-heading">
            <span class="method-name">request_post</span><span class="method-args">(path, data, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a POST request to the <tt>path</tt>.</p>

<p>Returns the response as a <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a>
object.</p>

<p>When called with a block, the block is passed an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.  The body of that
response will not have been read yet; the block can process it using <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html#method-i-read_body">HTTPResponse#read_body</a>, if
desired.</p>

<p>Returns the response.</p>

<p>This method never raises Net::* exceptions.</p>

<pre># example
response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')
p response.status
puts response.body          # body is already read in this case

# using block
http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|
  p response.status
  p response['content-type']
  response.read_body do |str|   # read body now
    print str
  end
}</pre>
            

            
            <div class="method-source-code" id="request_post-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1238</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">request_post</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">data</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>, &amp;<span class="ruby-identifier">block</span>) <span class="ruby-comment"># :yield: +response+</span>
  <span class="ruby-identifier">request</span> <span class="ruby-constant">Post</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">data</span>, &amp;<span class="ruby-identifier">block</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- request_post-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-post2">post2</a>
          </div>
          

          
        </div><!-- request_post-method -->

      
        <div id="send_request-method" class="method-detail ">
          <a name="method-i-send_request"></a>

          
          <div class="method-heading">
            <span class="method-name">send_request</span><span class="method-args">(name, path, data = nil, header = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends an HTTP request to the HTTP server. Also sends a DATA string if
<tt>data</tt> is given.</p>

<p>Returns a <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">Net::HTTPResponse</a> object.</p>

<p>This method never raises Net::* exceptions.</p>

<pre>response = http.send_request('GET', '/index.html')
puts response.body</pre>
            

            
            <div class="method-source-code" id="send_request-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1262</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send_request</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">data</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">header</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">r</span> = <span class="ruby-constant">HTTPGenericRequest</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">name</span>,(<span class="ruby-identifier">data</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>),<span class="ruby-keyword">true</span>,<span class="ruby-identifier">path</span>,<span class="ruby-identifier">header</span>)
  <span class="ruby-identifier">request</span> <span class="ruby-identifier">r</span>, <span class="ruby-identifier">data</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- send_request-source -->
            
          </div>

          

          
        </div><!-- send_request-method -->

      
        <div id="set_debug_output-method" class="method-detail ">
          <a name="method-i-set_debug_output"></a>

          
          <div class="method-heading">
            <span class="method-name">set_debug_output</span><span class="method-args">(output)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p><b>WARNING</b> This method opens a serious security hole. Never use this
method in production code.</p>

<p>Sets an output stream for debugging.</p>

<pre>http = Net::HTTP.new
http.set_debug_output $stderr
http.start { .... }</pre>
            

            
            <div class="method-source-code" id="set_debug_output-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 612</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">set_debug_output</span>(<span class="ruby-identifier">output</span>)
  <span class="ruby-identifier">warn</span> <span class="ruby-string">'Net::HTTP#set_debug_output called after HTTP started'</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">started?</span>
  <span class="ruby-ivar">@debug_output</span> = <span class="ruby-identifier">output</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- set_debug_output-source -->
            
          </div>

          

          
        </div><!-- set_debug_output-method -->

      
        <div id="start-method" class="method-detail ">
          <a name="method-i-start"></a>

          
          <div class="method-heading">
            <span class="method-name">start</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Opens a TCP connection and HTTP session.</p>

<p>When this method is called with a block, it passes the Net::HTTP object to
the block, and closes the TCP connection and HTTP session after the block
has been executed.</p>

<p>When called with a block, it returns the return value of the block;
otherwise, it returns self.</p>
            

            
            <div class="method-source-code" id="start-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 740</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">start</span>  <span class="ruby-comment"># :yield: http</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">IOError</span>, <span class="ruby-string">'HTTP session already opened'</span> <span class="ruby-keyword">if</span> <span class="ruby-ivar">@started</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-identifier">do_start</span>
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">yield</span>(<span class="ruby-keyword">self</span>)
    <span class="ruby-keyword">ensure</span>
      <span class="ruby-identifier">do_finish</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">do_start</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- start-source -->
            
          </div>

          

          
        </div><!-- start-method -->

      
        <div id="started-3F-method" class="method-detail ">
          <a name="method-i-started-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">started?</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns true if the HTTP session has been started.</p>
            

            
            <div class="method-source-code" id="started-3F-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 652</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">started?</span>
  <span class="ruby-ivar">@started</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- started-3F-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-active-3F">active?</a>
          </div>
          

          
        </div><!-- started-3F-method -->

      
        <div id="trace-method" class="method-detail ">
          <a name="method-i-trace"></a>

          
          <div class="method-heading">
            <span class="method-name">trace</span><span class="method-args">(path, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a TRACE request to the <tt>path</tt> and gets a response, as an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="trace-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1165</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">trace</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Trace</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>))
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- trace-source -->
            
          </div>

          

          
        </div><!-- trace-method -->

      
        <div id="unlock-method" class="method-detail ">
          <a name="method-i-unlock"></a>

          
          <div class="method-heading">
            <span class="method-name">unlock</span><span class="method-args">(path, body, initheader = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Sends a UNLOCK request to the <tt>path</tt> and gets a response, as an <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTPResponse.html">HTTPResponse</a> object.</p>
            

            
            <div class="method-source-code" id="unlock-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 1123</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">unlock</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">initheader</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">request</span>(<span class="ruby-constant">Unlock</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">initheader</span>), <span class="ruby-identifier">body</span>)
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- unlock-source -->
            
          </div>

          

          
        </div><!-- unlock-method -->

      
        <div id="use_ssl-3D-method" class="method-detail ">
          <a name="method-i-use_ssl-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">use_ssl=</span><span class="method-args">(flag)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Turn on/off SSL. This flag must be set before starting session. If you
change use_ssl value after session started, a Net::HTTP object raises
IOError.</p>
            

            
            <div class="method-source-code" id="use_ssl-3D-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 669</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">use_ssl=</span>(<span class="ruby-identifier">flag</span>)
  <span class="ruby-identifier">flag</span> = <span class="ruby-identifier">flag</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">started?</span> <span class="ruby-keyword">and</span> <span class="ruby-ivar">@use_ssl</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">flag</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">IOError</span>, <span class="ruby-string">"use_ssl value changed, but session already started"</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-ivar">@use_ssl</span> = <span class="ruby-identifier">flag</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- use_ssl-3D-source -->
            
          </div>

          

          
        </div><!-- use_ssl-3D-method -->

      
        <div id="use_ssl-3F-method" class="method-detail ">
          <a name="method-i-use_ssl-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">use_ssl?</span><span class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns true if SSL/TLS is being used with HTTP.</p>
            

            
            <div class="method-source-code" id="use_ssl-3F-source">
              <pre>              <code class="cpp"> <!-- How can we tell the language? Can we grab the file extension of the parsed source file? --> 
<span class="ruby-comment"># File net/http.rb, line 661</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">use_ssl?</span>
  <span class="ruby-ivar">@use_ssl</span>
<span class="ruby-keyword">end</span></code>
</pre> 
            </div><!-- use_ssl-3F-source -->
            
          </div>

          

          
        </div><!-- use_ssl-3F-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  

  </div><!-- documentation -->
<div id="disqus_thread"><div id="dsq-content" style="display: none; "></div><div id="dsq-content-stub"><img width="71" height="17" alt="DISQUS" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEcAAAARCAYAAAH4YIFjAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABwdJREFUeNpi/P//PwMhwAIiGBkZGeK6V8JVh9rqdfrc0ixnEDb+wPD2rAAjMSYBBBBRisDWwKxCthIE/q8Q+A8yhCiTAAIIrCi+ZxVMZSAQr19UGs4IMxWd/X8Rw3/GOKDhW43fgzwF1hX7n5EJ2dSp2QFNUKcZwJ31/78CkvPBGkGGMXidSUTWCxBAxAUAEQAcJzCvIXsDBPwsNBU2nbj+AMpdsFA8PAHsLZj3QC5D9hrIAEtN+RMwAzRkxcB0iK3eQ6iQIRAnoMTE//8CyHwmWHQdv/7QAiZ44/ErMP383acsqNB5iMnPlsFdsUZ6IU3CCCCA4AYBw8kBJgj06gGkmHJAFgPyQV4ExeQEoNgHJHUBQMoAWRzoerBeYHgeQOJ/APIvQPkNUP4EuIdADBAGBRMQOABxQcakdSipHZldNGvL2zWHL8kD1d0HieVN33QYqnc/EAfULNwJVw8KTniQwvjAdPz/SEwKmL1KfC5QjwEQr4e5AyVdA3P4ASCe8O3nb1whmtib6r3IXlfpATBEFbpWH9ygJSdmBtXrOHPbyZWPXn1AqOZRwDSBS+YHo82SOQwiZnYMoS+EGC42nGdYzBiAnKpgGAbeA3ECkjwYQNnzH758///6o5cgofVIagy+/vgFF//y/ecHJLn1/18AA+/teZBcPZL4eSTxBJg7AAKIaomRmpkeV2IG5UcDpMSsAM2zF4BiG9DUFaCLQxPwBWCC/QBkg/QqoCVuEN4ASuDIaWc/DIMSItBxH0GCrkaqCVBxWO4BJWBQcK/PmrL+I1S8H0i9h4mjFfX7GTRyIdEuHzIfZtb/Zdw3oGyQnvP/d9pNgRc+MLCwJMxxWk7AI6Ar+YCWVSLLyYkJzIYlZqC6RGBhbg/lFwDlQHoDgfgALLfhjY8/X9XhpWPs/wWM7odyMBwDylU8nOzyILYIH3cZslxBgM0cKHM+MOTAGCZnri7XCdS7ASgGLsc/fPlug9cxlrO/wUvYxYwJwCgLwHAMcrVlqCJ9BVlchJ+7EhRyQPwAyGaAFnhgsOPMzUhQroLVAU76yp/gGp/vtQbTr45pwMWOp1oDQ6QQiGEi6+EJGLmah0YJQ6CVtu3ivecKYHIpE9b8BPqcDSnawHSSu8m3eTvPyAHlzsPkDl25/wXMYAOq+XgtBFwIfn/GwCAOSq8HYCGCsNh8+hvksgYZIJchDkjljAKoHAKVJ6ByBbnmA5XESOL1oFIZSc9/cJkC1IukPuH/z/cw8fswdwyqcgYgwAaVYwYbQEnDSI1LbGABEDcCC1lYS4yhfO42n+fvPm9GKsAZkfJDA7RcwwYmQM1CbpUUADU3AB3AjxJ7wFwAFGsAqp2A0mBDahww8Gv4Mvrf2AKXWyMzgeHbk3wwh5X/DGPkR1OoHlCmn49cGCABkL8SgZn8ANbAQQaV4ZBK6yGwgbDr3G2GNx+/gkqShMTe1V///vsnA/KYjoKECjBwMPQCW0EngOrNQWxbHQWGFA8zBlAj5eztpwwbjl9lyPG1DFOUEAIFDqxJB6ksoC1ZN2NVsDm7zt4GNUhBgdUPrXwckWtQOJB0VQE2XRF8UQt9hodrIGw+FaDcWVjAwAshhsD7kAbPO2Dr78ZEBoZfHxQYHNYbwEogvIGjKSfOiNysBpaEL/acv8MODBhuUX7u00BhVVx6DZWlxHcDAxQEDl95AMZQAGqHLlSSFIanAnZWll0/f/8Bs2OcDB+5GavJVyGZtevsrYdL9p2XQ6rZGcnKI54nZRj2uoMCAVr4K8JkQAKgJsdEYN12AbmYYSGqYGJk/NC8bO91WHKUFRXgwace6ElDIF4PjHWHc3eeMZy98xSU8mB1mwE0FSQCU8ECZiZGVpi+yw9eLIfVlUyMjIf+/f/Pu/bIlTtIdSX5hauo+RagxxMZfr2fwHB3IT/Dy4MMDI/BzTABaP2aAGzmgPpN4gQDB1pmgIA+EAfcfvoGXl/mB1hXFuBxCLDs6oc26kBJZiIoxShLCqs9e/tp+vdfv8ENB08Tdf9FwHKsMtxxTfvK/SGgbHfx3vNyoL2g7DjR30r74vqjV2yA6lXgbnI2WtoH4yhEfGF4sAISSTcm9wOzDcidoE6lPTBLwRuyDMoJ5+DZagnLJIb/f3mh5edGcKoRs+5neHUUUgZxiIrhrK2wFchc7KwMmsByANjiAZUfoGzhCEpJIDlQowOYffqRC2RQS+f1x68HNx6/ygcqY9A7RMZAc5LcTS/zcLLZwcwB1evAzs/8pfsvwDu9yOplgRECzF4M8a7Gryw05NRB+sDtiC/3HjKcKeaDpgAEADVmNIDlsX4DqFPmCOvvMNxdkAAuX95dQFUPKnv06kEBmQgNOLpV5QbQpAsrcz4QUC+AVJsgqxcgoNcBqQy5QIIdONUDALcn6c0dtMJ9AAAAAElFTkSuQmCC"><img width="16" height="11" alt="..." src="data:image/gif;base64,R0lGODlhEAALAPQAAP///z2LqeLt8dvp7u7090GNqz2LqV+fuJ/F1IW2ycrf51aatHWswaXJ14i4ys3h6FmctUCMqniuw+vz9eHs8fb5+meku+Tu8vT4+cfd5bbT3tbm7PH2+AAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCwAAACwAAAAAEAALAAAFLSAgjmRpnqSgCuLKAq5AEIM4zDVw03ve27ifDgfkEYe04kDIDC5zrtYKRa2WQgAh+QQJCwAAACwAAAAAEAALAAAFJGBhGAVgnqhpHIeRvsDawqns0qeN5+y967tYLyicBYE7EYkYAgAh+QQJCwAAACwAAAAAEAALAAAFNiAgjothLOOIJAkiGgxjpGKiKMkbz7SN6zIawJcDwIK9W/HISxGBzdHTuBNOmcJVCyoUlk7CEAAh+QQJCwAAACwAAAAAEAALAAAFNSAgjqQIRRFUAo3jNGIkSdHqPI8Tz3V55zuaDacDyIQ+YrBH+hWPzJFzOQQaeavWi7oqnVIhACH5BAkLAAAALAAAAAAQAAsAAAUyICCOZGme1rJY5kRRk7hI0mJSVUXJtF3iOl7tltsBZsNfUegjAY3I5sgFY55KqdX1GgIAIfkECQsAAAAsAAAAABAACwAABTcgII5kaZ4kcV2EqLJipmnZhWGXaOOitm2aXQ4g7P2Ct2ER4AMul00kj5g0Al8tADY2y6C+4FIIACH5BAkLAAAALAAAAAAQAAsAAAUvICCOZGme5ERRk6iy7qpyHCVStA3gNa/7txxwlwv2isSacYUc+l4tADQGQ1mvpBAAIfkECQsAAAAsAAAAABAACwAABS8gII5kaZ7kRFGTqLLuqnIcJVK0DeA1r/u3HHCXC/aKxJpxhRz6Xi0ANAZDWa+kEAA7AAAAAAAAAAAA" style="margin:0 0 3px 5px"></div></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    // var disqus_shortname = 'rubydocbeta'; // required 
    var disqus_shortname = 'ruby-doc'; // required 
    
    var disqus_developer = true; // DEBUGGERY
    


    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the &lt;a href="http://disqus.com/?ref_noscript"&gt;comments powered by Disqus.&lt;/a&gt;</noscript>
<a href="http://disqus.com/" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

<div class="grids wrapper" id="footer">
  <p><small>This page was generated for Ruby 1.9.3</small></p> 
  
   <p> <a href="http://www.ruby-doc.org/">Ruby-doc.org</a> is provided by <a href="http://www.jamesbritt.com/">James Britt</a> and <a href="http://www.neurogami.com/">Neurogami</a>. <a href="http://www.neurogami.com/">Maximum R+D</a>.  </p>
 
    <p><small>Generated with the <a href="http://neurogami.com/code/">Rubydoc Rdoc Generator</a> 0.9.4</small>.</p>
  </div>

</div>

<script type="text/javascript">
var _uacct = "UA-335317-2";
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script><script src="./Class  Net  HTTPSession (Ruby 1.9.3)_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">
try{ 
var pageTracker = _gat._getTracker(_uacct);
pageTracker._trackPageview();
} catch(err) {} 
</script>



</body></html>